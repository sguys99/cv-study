# Hugging Face 튜토리얼 Part 5.2: Custom Tool 개발

## 학습 목표
- Vision Tool 및 VLM Agent 구현
- Web Browser Agent (Selenium + Helium)
- MCP (Model Context Protocol) 통합
- RAG Tool 및 Agentic RAG 시스템
- Text-to-SQL Agent 구현
- 프로덕션 배포 고려사항

---

## 1. Vision Tool & VLM Agent

### 1.1 Vision Agent 개요

```
┌─────────────────────────────────────────────────────────────┐
│                    Vision Agent Flow                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [이미지 입력] ──▶ [VLM 분석] ──▶ [Tool 호출] ──▶ [결과]   │
│        │                                                    │
│        └── 스크린샷, 문서, 웹페이지, 카메라 등              │
│                                                             │
│   사용 사례:                                                │
│   • Document AI (문서 분석)                                 │
│   • Web Browsing (스크린샷 기반 네비게이션)                 │
│   • GUI Automation (UI 요소 인식)                           │
│   • Visual QA (이미지 질의응답)                             │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 이미지 입력 방식

smolagents는 두 가지 이미지 입력 방식 지원:

| 방식 | 설명 | 사용 사례 |
|------|------|----------|
| **초기 제공** | 실행 시 이미지 전달 | Document AI, 이미지 분석 |
| **동적 추가** | 실행 중 이미지 추가 | Web Browsing, GUI 제어 |

### 1.3 기본 Vision Agent

```python
from smolagents import CodeAgent, InferenceClientModel

# VLM 모델 초기화
model = InferenceClientModel(
    model_id="Qwen/Qwen2-VL-72B-Instruct",  # Vision 지원 모델
)

# Vision Agent 생성
agent = CodeAgent(
    tools=[],
    model=model,
)

# 이미지와 함께 실행
result = agent.run(
    "이 문서의 주요 내용을 요약해주세요.",
    images=["document.png"],  # 이미지 경로 또는 PIL Image
)
print(result)
```

### 1.4 이미지 생성 Tool

```python
from smolagents import Tool
from huggingface_hub import InferenceClient


class TextToImageTool(Tool):
    """텍스트로 이미지 생성"""
    
    name = "image_generator"
    description = """
    프롬프트를 기반으로 이미지를 생성합니다.
    더 좋은 결과를 위해 'high-res, photorealistic' 등의
    품질 키워드를 추가하세요.
    """
    inputs = {
        "prompt": {
            "type": "string",
            "description": "생성할 이미지 설명",
        }
    }
    output_type = "image"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.client = InferenceClient("black-forest-labs/FLUX.1-schnell")
    
    def forward(self, prompt: str):
        return self.client.text_to_image(prompt)


# 사용
from smolagents import CodeAgent, InferenceClientModel

image_tool = TextToImageTool()
agent = CodeAgent(
    tools=[image_tool],
    model=InferenceClientModel(),
)

result = agent.run("우주에서 본 지구 이미지를 생성해줘")
```

### 1.5 이미지 분석 Tool

```python
from smolagents import Tool
from transformers import pipeline
from PIL import Image


class ImageClassifierTool(Tool):
    """이미지 분류 도구"""
    
    name = "image_classifier"
    description = "이미지를 분류하고 레이블을 반환합니다."
    inputs = {
        "image_path": {
            "type": "string",
            "description": "분석할 이미지 경로",
        }
    }
    output_type = "string"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.classifier = pipeline(
            "image-classification",
            model="google/vit-base-patch16-224"
        )
    
    def forward(self, image_path: str) -> str:
        image = Image.open(image_path)
        results = self.classifier(image)
        
        output = "분류 결과:\n"
        for r in results[:5]:
            output += f"- {r['label']}: {r['score']:.2%}\n"
        return output


class ObjectDetectorTool(Tool):
    """객체 탐지 도구"""
    
    name = "object_detector"
    description = "이미지에서 객체를 탐지하고 위치를 반환합니다."
    inputs = {
        "image_path": {
            "type": "string",
            "description": "분석할 이미지 경로",
        }
    }
    output_type = "string"
    
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.detector = pipeline(
            "object-detection",
            model="facebook/detr-resnet-50"
        )
    
    def forward(self, image_path: str) -> str:
        image = Image.open(image_path)
        results = self.detector(image)
        
        output = "탐지된 객체:\n"
        for obj in results:
            output += f"- {obj['label']}: {obj['score']:.2%} "
            output += f"(위치: {obj['box']})\n"
        return output
```

---

## 2. Web Browser Agent

### 2.1 개요

Web Browser Agent는 VLM + Selenium/Helium을 결합하여 웹 자동화 수행:

```
┌─────────────────────────────────────────────────────────────┐
│                  Web Browser Agent                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   [Task] ──▶ [스크린샷 캡처] ──▶ [VLM 분석]                │
│                    │                                        │
│                    ▼                                        │
│            [Helium 액션 실행]                               │
│                    │                                        │
│                    ▼                                        │
│            [결과 확인] ──▶ [반복/종료]                      │
│                                                             │
│   지원 액션: click, write, go_to, scroll, press 등         │
└─────────────────────────────────────────────────────────────┘
```

### 2.2 설치

```bash
pip install smolagents selenium helium pillow python-dotenv
```

### 2.3 기본 설정

```python
from io import BytesIO
from time import sleep

import helium
from PIL import Image
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys

from smolagents import CodeAgent, tool, InferenceClientModel
from smolagents.agents import ActionStep

# Chrome 옵션 설정
chrome_options = webdriver.ChromeOptions()
chrome_options.add_argument("--force-device-scale-factor=1")
chrome_options.add_argument("--window-size=1000,1350")
chrome_options.add_argument("--disable-pdf-viewer")
chrome_options.add_argument("--window-position=0,0")

# 브라우저 시작
driver = helium.start_chrome(headless=False, options=chrome_options)
```

### 2.4 스크린샷 콜백 설정

```python
def save_screenshot(memory_step: ActionStep, agent: CodeAgent) -> None:
    """각 스텝 후 스크린샷 캡처"""
    sleep(1.0)  # JavaScript 애니메이션 대기
    
    driver = helium.get_driver()
    current_step = memory_step.step_number
    
    if driver is not None:
        # 이전 스크린샷 정리 (메모리 절약)
        for prev_step in agent.memory.steps:
            if (isinstance(prev_step, ActionStep) and 
                prev_step.step_number <= current_step - 2):
                prev_step.observations_images = None
        
        # 새 스크린샷 캡처
        png_bytes = driver.get_screenshot_as_png()
        image = Image.open(BytesIO(png_bytes))
        print(f"스크린샷 캡처: Step {current_step}")
        
        # 메모리에 저장
        memory_step.observations_images = [image]
```

### 2.5 브라우저 Tool 정의

```python
@tool
def search_item_ctrl_f(text: str, nth_result: int = 1) -> str:
    """
    Ctrl+F로 페이지 내 텍스트 검색 후 n번째 결과로 이동
    
    Args:
        text: 검색할 텍스트
        nth_result: 이동할 결과 번호 (기본: 1)
    
    Returns:
        검색 결과 상태
    """
    elements = driver.find_elements(By.XPATH, f"//*[contains(text(), '{text}')]")
    
    if not elements:
        return f"'{text}'를 찾을 수 없습니다."
    
    if nth_result > len(elements):
        return f"'{text}' 결과가 {len(elements)}개뿐입니다. {nth_result}번째 결과 없음."
    
    # 해당 요소로 스크롤
    result_element = elements[nth_result - 1]
    driver.execute_script(
        "arguments[0].scrollIntoView(true);",
        result_element
    )
    return f"'{text}' {nth_result}번째 결과로 이동 완료"


@tool
def go_back() -> str:
    """브라우저 뒤로가기"""
    driver.back()
    return "이전 페이지로 이동"


@tool
def close_popups() -> str:
    """팝업 닫기 시도"""
    try:
        # 일반적인 팝업 닫기 버튼 클릭 시도
        for selector in ["button[aria-label='Close']", ".close", ".modal-close"]:
            try:
                elements = driver.find_elements(By.CSS_SELECTOR, selector)
                for el in elements:
                    if el.is_displayed():
                        el.click()
                        return "팝업 닫힘"
            except:
                continue
        
        # ESC 키로 닫기 시도
        from selenium.webdriver.common.action_chains import ActionChains
        ActionChains(driver).send_keys(Keys.ESCAPE).perform()
        return "ESC 키로 팝업 닫기 시도"
    except Exception as e:
        return f"팝업 닫기 실패: {e}"
```

### 2.6 Web Agent 생성 및 실행

```python
from smolagents import InferenceClientModel

# VLM 모델 초기화 (Vision 필수!)
model = InferenceClientModel(
    model_id="meta-llama/Llama-3.3-70B-Instruct",
)

# 또는 GPT-4o 사용 (권장)
from smolagents import LiteLLMModel
model = LiteLLMModel(model_id="gpt-4o")

# Agent 생성
agent = CodeAgent(
    tools=[go_back, close_popups, search_item_ctrl_f],
    model=model,
    additional_authorized_imports=["helium"],
    step_callbacks=[save_screenshot],
    max_steps=20,
    verbosity_level=2,
)

# Helium import 사전 실행
agent.python_executor("from helium import *", agent.state)
```

### 2.7 Helium 사용 지침

```python
helium_instructions = """
Helium을 사용하여 웹사이트에 접근할 수 있습니다.
드라이버는 이미 관리되고 있으니 신경쓰지 마세요.
"from helium import *"가 이미 실행되었습니다.

페이지 이동:
```py
go_to('github.com/trending')
```

버튼/링크 클릭 (표시된 텍스트로):
```py
click("Sign in")
```

텍스트 입력:
```py
write("검색어", into="Search")
```

스크롤:
```py
scroll_down(num_pixels=1200)
```

중요 규칙:
- 각 액션 후 스크린샷을 확인하세요
- 코드 기반 요소 검색 대신 스크린샷을 시각적으로 분석하세요
- 브라우저를 종료하지 마세요
"""
```

### 2.8 실행 예시

```python
# Wikipedia에서 정보 검색
search_request = """
https://en.wikipedia.org/wiki/Seoul 페이지로 이동해서
'population' 단어가 포함된 문장을 찾아 알려줘.
"""

agent_output = agent.run(search_request + helium_instructions)
print("최종 결과:")
print(agent_output)

# GitHub 트렌딩 분석
github_request = """
github.com/trending 페이지로 이동해서
1위 저장소의 스타 수와 설명을 알려줘.
"""

agent_output = agent.run(github_request + helium_instructions)
print(agent_output)
```

### 2.9 CLI webagent 사용

```bash
# webagent CLI 직접 사용
webagent "github.com/trending에서 1위 저장소 정보 가져와" \
    --model-type "LiteLLMModel" \
    --model-id "gpt-4o"
```

---

## 3. MCP (Model Context Protocol) 통합

### 3.1 MCP 개요

```
┌─────────────────────────────────────────────────────────────┐
│                Model Context Protocol (MCP)                 │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   MCP = AI를 위한 USB-C 포트                                │
│                                                             │
│   ┌─────────┐      JSON-RPC 2.0      ┌─────────┐           │
│   │   AI    │ ◀──────────────────▶  │   MCP   │           │
│   │  Agent  │                        │ Server  │           │
│   └─────────┘                        └─────────┘           │
│                                            │                │
│                     ┌──────────────────────┼────────┐      │
│                     ▼          ▼           ▼        ▼      │
│                 [GitHub]  [Slack]   [Database]  [Files]    │
│                                                             │
│   • 2024년 11월 Anthropic 발표                             │
│   • OpenAI, Google 채택                                    │
│   • 650+ MCP 서버 존재                                     │
└─────────────────────────────────────────────────────────────┘
```

### 3.2 MCP 설치

```bash
# smolagents MCP 지원 설치
pip install "smolagents[mcp]"

# 또는 mcpadapt 사용
pip install mcpadapt[smolagents]
```

### 3.3 MCP Server 연결 (smolagents 내장)

```python
from mcp import StdioServerParameters
from smolagents import ToolCollection, CodeAgent, InferenceClientModel

# MCP 서버 파라미터 설정
server_params = StdioServerParameters(
    command="uvx",
    args=["mcp-server-fetch"],  # fetch MCP 서버
)

# MCP Tool Collection으로 Agent 구성
with ToolCollection.from_mcp(server_params) as tools:
    agent = CodeAgent(
        tools=tools,
        model=InferenceClientModel(),
        add_base_tools=True,
    )
    
    result = agent.run("https://huggingface.co 페이지 내용을 가져와줘")
    print(result)
```

### 3.4 MCPClient 사용

```python
from smolagents import MCPClient, CodeAgent, InferenceClientModel

# MCP 클라이언트 설정
server_params = {
    "command": "npx",
    "args": ["-y", "@anthropic/mcp-server-github"],
    "env": {"GITHUB_TOKEN": "your-token"},
}

# MCP 클라이언트로 Tool 로드
with MCPClient(server_params) as tools:
    agent = CodeAgent(
        tools=tools,
        model=InferenceClientModel(),
    )
    
    result = agent.run("huggingface/smolagents 저장소의 최근 이슈 목록을 보여줘")
    print(result)
```

### 3.5 mcpadapt로 MCP 연결

```python
from mcp import StdioServerParameters
from mcpadapt.core import MCPAdapt
from mcpadapt.smolagents_adapter import SmolAgentsAdapter
from smolagents import CodeAgent, InferenceClientModel

# MCP 서버 파라미터
server_params = StdioServerParameters(
    command="uvx",
    args=["mcp-server-time"],  # 시간 MCP 서버
)

# MCPAdapt로 Tool 변환
with MCPAdapt(server_params, SmolAgentsAdapter()) as tools:
    agent = CodeAgent(
        tools=tools,
        model=InferenceClientModel(),
    )
    
    result = agent.run("현재 서울 시간을 알려줘")
    print(result)
```

### 3.6 여러 MCP 서버 동시 사용

```python
from mcp import StdioServerParameters
from mcpadapt.core import MCPAdapt
from mcpadapt.smolagents_adapter import SmolAgentsAdapter

# 여러 MCP 서버 정의
servers = [
    StdioServerParameters(command="uvx", args=["mcp-server-fetch"]),
    StdioServerParameters(command="uvx", args=["mcp-server-time"]),
]

# 모든 서버의 Tool을 통합
with MCPAdapt(servers, SmolAgentsAdapter()) as tools:
    agent = CodeAgent(
        tools=tools,
        model=InferenceClientModel(),
    )
    
    result = agent.run("""
    1. 현재 시간을 확인하고
    2. https://news.ycombinator.com 의 헤드라인을 가져와줘
    """)
    print(result)
```

### 3.7 커스텀 MCP 서버 구현 (FastMCP)

```python
# mcp_server.py
from fastmcp import FastMCP

mcp = FastMCP("my-tools")


@mcp.tool()
def get_weather(city: str) -> str:
    """도시의 날씨 정보를 반환합니다."""
    # 실제 구현에서는 API 호출
    return f"{city}의 날씨: 맑음, 15°C"


@mcp.tool()
def search_database(query: str) -> str:
    """데이터베이스를 검색합니다."""
    return f"검색 결과: '{query}'에 대한 10개 항목 발견"


if __name__ == "__main__":
    mcp.run()
```

```python
# Agent에서 사용
from mcp import StdioServerParameters
from smolagents import ToolCollection, CodeAgent, InferenceClientModel

server_params = StdioServerParameters(
    command="python",
    args=["mcp_server.py"],
)

with ToolCollection.from_mcp(server_params) as tools:
    agent = CodeAgent(
        tools=tools,
        model=InferenceClientModel(),
    )
    
    result = agent.run("서울 날씨를 알려주고, '인공지능' 관련 데이터를 검색해줘")
```

---

## 4. RAG Tool & Agentic RAG

### 4.1 Agentic RAG vs 기존 RAG

```
┌─────────────────────────────────────────────────────────────┐
│              기존 RAG vs Agentic RAG                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [기존 RAG]                                                 │
│   Query ──▶ Retrieve(1회) ──▶ Generate ──▶ Answer          │
│                                                             │
│  문제점:                                                    │
│   • 단일 검색으로 관련 문서 놓칠 수 있음                    │
│   • 쿼리-문서 불일치 시 대응 불가                           │
│   • 검색 결과 품질 검증 없음                                │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [Agentic RAG]                                              │
│   Query ──▶ [Agent: 판단] ──▶ Retrieve ──▶ [평가]          │
│                  │              │            │              │
│                  │              │            ▼              │
│                  │              │    결과 불충분?           │
│                  │              │         │                 │
│                  │              ◀─────────┘ (쿼리 수정)     │
│                  │                                          │
│                  └──────▶ Generate ──▶ Answer               │
│                                                             │
│  장점:                                                      │
│   • 반복 검색으로 품질 향상                                 │
│   • 쿼리 재구성 (HyDE, Self-Query)                         │
│   • 다양한 Tool 조합 가능                                   │
└─────────────────────────────────────────────────────────────┘
```

### 4.2 RetrieverTool 구현

```python
from smolagents import Tool
from langchain_community.retrievers import BM25Retriever
from langchain_community.docstore.document import Document
from langchain_text_splitters import RecursiveCharacterTextSplitter


class RetrieverTool(Tool):
    """문서 검색 도구"""
    
    name = "retriever"
    description = """
    지식 베이스에서 쿼리와 관련된 문서를 검색합니다.
    질문보다는 평서문 형태로 쿼리를 작성하세요.
    """
    inputs = {
        "query": {
            "type": "string",
            "description": "검색 쿼리 (문서와 의미적으로 유사해야 함)",
        }
    }
    output_type = "string"
    
    def __init__(self, documents: list, **kwargs):
        super().__init__(**kwargs)
        
        # 문서 청킹
        text_splitter = RecursiveCharacterTextSplitter(
            chunk_size=500,
            chunk_overlap=50,
            separators=["\n\n", "\n", ".", " ", ""],
        )
        self.docs = text_splitter.split_documents(documents)
        
        # BM25 Retriever 초기화
        self.retriever = BM25Retriever.from_documents(self.docs, k=5)
    
    def forward(self, query: str) -> str:
        results = self.retriever.invoke(query)
        
        if not results:
            return "관련 문서를 찾을 수 없습니다."
        
        output = ""
        for i, doc in enumerate(results):
            output += f"\n\n===== Document {i+1} =====\n"
            output += doc.page_content
        
        return output
```

### 4.3 Vector Retriever Tool (임베딩 기반)

```python
from smolagents import Tool
from langchain_community.vectorstores import FAISS
from langchain_huggingface import HuggingFaceEmbeddings


class VectorRetrieverTool(Tool):
    """벡터 검색 기반 문서 검색"""
    
    name = "vector_retriever"
    description = """
    임베딩 기반 의미 검색으로 관련 문서를 찾습니다.
    """
    inputs = {
        "query": {
            "type": "string",
            "description": "검색 쿼리",
        },
        "top_k": {
            "type": "integer",
            "description": "반환할 문서 수 (기본: 5)",
            "nullable": True,
        }
    }
    output_type = "string"
    
    def __init__(self, documents: list, **kwargs):
        super().__init__(**kwargs)
        
        # 임베딩 모델
        embeddings = HuggingFaceEmbeddings(
            model_name="sentence-transformers/all-MiniLM-L6-v2"
        )
        
        # Vector Store 생성
        self.vectorstore = FAISS.from_documents(documents, embeddings)
    
    def forward(self, query: str, top_k: int = 5) -> str:
        results = self.vectorstore.similarity_search(query, k=top_k)
        
        output = f"검색 결과 ({len(results)}개):\n"
        for i, doc in enumerate(results):
            output += f"\n[{i+1}] {doc.page_content[:200]}..."
            if doc.metadata:
                output += f"\n    출처: {doc.metadata.get('source', 'N/A')}"
        
        return output
```

### 4.4 Agentic RAG Agent 구성

```python
import datasets
from langchain_community.docstore.document import Document
from langchain_text_splitters import RecursiveCharacterTextSplitter
from smolagents import CodeAgent, InferenceClientModel

# 데이터셋 로드 (예: HuggingFace 문서)
knowledge_base = datasets.load_dataset(
    "m-ric/huggingface_doc",
    split="train"
)

# transformers 문서만 필터링
knowledge_base = knowledge_base.filter(
    lambda row: row["source"].startswith("huggingface/transformers")
)

# Document 객체로 변환
source_docs = [
    Document(
        page_content=doc["text"],
        metadata={"source": doc["source"].split("/")[1]}
    )
    for doc in knowledge_base
]

# 청킹
text_splitter = RecursiveCharacterTextSplitter(
    chunk_size=500,
    chunk_overlap=50,
)
docs_processed = text_splitter.split_documents(source_docs)

print(f"총 {len(docs_processed)}개 청크 생성")

# Retriever Tool 생성
retriever_tool = RetrieverTool(docs_processed)

# Agent 생성
agent = CodeAgent(
    tools=[retriever_tool],
    model=InferenceClientModel(model_id="Qwen/Qwen2.5-72B-Instruct"),
    max_steps=4,
    verbosity_level=2,
)

# 실행
result = agent.run(
    "transformers 모델 학습에서 forward와 backward 중 어느 것이 더 느린가요?"
)
print(result)
```

### 4.5 고급 Agentic RAG (소스 필터링)

```python
from smolagents import Tool


class AdvancedRetrieverTool(Tool):
    """소스 필터링이 가능한 고급 검색 도구"""
    
    name = "advanced_retriever"
    description = """
    지식 베이스에서 문서를 검색합니다.
    특정 소스로 필터링할 수 있습니다.
    사용 가능한 소스: {sources}
    """
    inputs = {
        "query": {
            "type": "string",
            "description": "검색 쿼리",
        },
        "source": {
            "type": "string",
            "description": "필터링할 소스 (선택)",
            "nullable": True,
        },
        "top_k": {
            "type": "integer",
            "description": "반환할 문서 수",
            "nullable": True,
        }
    }
    output_type = "string"
    
    def __init__(self, vectorstore, all_sources: list, **kwargs):
        super().__init__(**kwargs)
        self.vectorstore = vectorstore
        self.all_sources = all_sources
        # description에 소스 목록 삽입
        self.description = self.description.format(
            sources=", ".join(all_sources)
        )
    
    def forward(
        self, 
        query: str, 
        source: str = None, 
        top_k: int = 5
    ) -> str:
        # 필터 설정
        filter_dict = {"source": source} if source else None
        
        # 검색
        results = self.vectorstore.similarity_search(
            query,
            k=top_k,
            filter=filter_dict
        )
        
        if not results:
            return f"'{query}'에 대한 결과 없음. 다른 소스나 쿼리를 시도하세요."
        
        output = f"검색 결과 ({len(results)}개):\n"
        for i, doc in enumerate(results):
            output += f"\n===== [{doc.metadata.get('source', 'N/A')}] =====\n"
            output += doc.page_content
        
        return output
```

### 4.6 Web Search + RAG 조합

```python
from smolagents import CodeAgent, InferenceClientModel, DuckDuckGoSearchTool

# Web Search + Local RAG 조합
agent = CodeAgent(
    tools=[
        retriever_tool,           # 로컬 지식 베이스
        DuckDuckGoSearchTool(),   # 웹 검색
    ],
    model=InferenceClientModel(),
)

result = agent.run("""
먼저 로컬 문서에서 'fine-tuning'에 대해 검색하고,
최신 정보가 필요하면 웹에서 추가 검색해줘.
""")
```

---

## 5. Text-to-SQL Agent

### 5.1 개요

```
┌─────────────────────────────────────────────────────────────┐
│               Text-to-SQL Agent 장점                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [기존 Text-to-SQL]                                         │
│   "가장 비싼 주문?" ──▶ SQL 생성 ──▶ 실행 ──▶ 결과         │
│                                                             │
│   문제: SQL 오류 시 대응 불가, 잘못된 결과 검증 안됨        │
│                                                             │
│  [Agentic Text-to-SQL]                                      │
│   "가장 비싼 주문?" ──▶ SQL 생성 ──▶ 실행 ──▶ 결과 검증    │
│                              │              │               │
│                              │              ▼               │
│                              │         오류/이상?           │
│                              │              │               │
│                              ◀──────────────┘ (수정)        │
│                                                             │
│   장점: 오류 자동 수정, 결과 검증, 반복 개선                │
└─────────────────────────────────────────────────────────────┘
```

### 5.2 데이터베이스 설정

```python
from sqlalchemy import create_engine, MetaData, Table, Column
from sqlalchemy import Integer, String, Float, inspect, text

# SQLite 인메모리 DB 생성
engine = create_engine("sqlite:///:memory:")
metadata_obj = MetaData()

# 테이블 정의
receipts = Table(
    "receipts",
    metadata_obj,
    Column("receipt_id", Integer, primary_key=True),
    Column("customer_name", String(16)),
    Column("price", Float),
    Column("tip", Float),
)

# 테이블 생성
metadata_obj.create_all(engine)

# 데이터 삽입
rows = [
    {"receipt_id": 1, "customer_name": "김철수", "price": 15000, "tip": 1500},
    {"receipt_id": 2, "customer_name": "이영희", "price": 28000, "tip": 3000},
    {"receipt_id": 3, "customer_name": "박민수", "price": 42000, "tip": 5000},
    {"receipt_id": 4, "customer_name": "정수진", "price": 18500, "tip": 2000},
]

with engine.begin() as conn:
    for row in rows:
        conn.execute(receipts.insert().values(**row))

print("테이블 생성 및 데이터 삽입 완료")
```

### 5.3 테이블 스키마 추출

```python
# 테이블 스키마 정보 추출
inspector = inspect(engine)
columns_info = [
    (col["name"], col["type"]) 
    for col in inspector.get_columns("receipts")
]

table_description = "Columns:\n" + "\n".join(
    [f"  - {name}: {col_type}" for name, col_type in columns_info]
)

print(table_description)
# Columns:
#   - receipt_id: INTEGER
#   - customer_name: VARCHAR(16)
#   - price: FLOAT
#   - tip: FLOAT
```

### 5.4 SQL Tool 구현

```python
from smolagents import tool


@tool
def sql_engine(query: str) -> str:
    """
    SQL 쿼리를 실행하고 결과를 반환합니다.
    
    테이블: 'receipts'
    컬럼:
      - receipt_id: INTEGER (주문 ID)
      - customer_name: VARCHAR(16) (고객 이름)
      - price: FLOAT (주문 금액)
      - tip: FLOAT (팁)
    
    Args:
        query: 실행할 SQL 쿼리 (올바른 SQL 문법 필요)
    
    Returns:
        쿼리 결과 문자열
    """
    try:
        output = ""
        with engine.connect() as conn:
            result = conn.execute(text(query))
            rows = result.fetchall()
            
            if not rows:
                return "쿼리 결과가 없습니다."
            
            # 컬럼 이름
            columns = result.keys()
            output += " | ".join(columns) + "\n"
            output += "-" * 50 + "\n"
            
            # 데이터
            for row in rows:
                output += " | ".join(str(v) for v in row) + "\n"
        
        return output
    except Exception as e:
        return f"SQL 오류: {e}"
```

### 5.5 Text-to-SQL Agent 생성

```python
from smolagents import CodeAgent, InferenceClientModel

# Agent 생성
agent = CodeAgent(
    tools=[sql_engine],
    model=InferenceClientModel(model_id="Qwen/Qwen2.5-72B-Instruct"),
    max_steps=5,
)

# 자연어 질의
result = agent.run("가장 비싼 주문을 한 고객의 이름은?")
print(result)

result = agent.run("팁을 가장 많이 받은 주문의 정보를 알려줘")
print(result)

result = agent.run("전체 매출과 팁의 합계는?")
print(result)
```

### 5.6 Multi-Table Join 지원

```python
# 두 번째 테이블 추가
waiters = Table(
    "waiters",
    metadata_obj,
    Column("receipt_id", Integer, primary_key=True),
    Column("waiter_name", String(16)),
)
metadata_obj.create_all(engine)

# 웨이터 데이터 삽입
waiter_rows = [
    {"receipt_id": 1, "waiter_name": "Alice"},
    {"receipt_id": 2, "waiter_name": "Bob"},
    {"receipt_id": 3, "waiter_name": "Alice"},
    {"receipt_id": 4, "waiter_name": "Charlie"},
]

with engine.begin() as conn:
    for row in waiter_rows:
        conn.execute(waiters.insert().values(**row))

# Tool 설명 업데이트
updated_sql_tool_description = """
SQL 쿼리를 실행합니다.

테이블 1: 'receipts'
  - receipt_id: INTEGER (PK)
  - customer_name: VARCHAR(16)
  - price: FLOAT
  - tip: FLOAT

테이블 2: 'waiters'
  - receipt_id: INTEGER (PK, FK → receipts)
  - waiter_name: VARCHAR(16)

Args:
    query: SQL 쿼리
"""

# Tool description 업데이트
sql_engine.description = updated_sql_tool_description

# 새 Agent 생성
agent = CodeAgent(
    tools=[sql_engine],
    model=InferenceClientModel(model_id="Qwen/Qwen2.5-72B-Instruct"),
)

# JOIN 쿼리 테스트
result = agent.run("어느 웨이터가 팁을 가장 많이 받았나요?")
print(result)
```

### 5.7 고급 SQL Tool (스키마 자동 추출)

```python
from smolagents import Tool
from sqlalchemy import inspect, create_engine, text


class SQLTool(Tool):
    """자동 스키마 추출 SQL Tool"""
    
    name = "sql_executor"
    description = "SQL 쿼리를 실행합니다."
    inputs = {
        "query": {
            "type": "string",
            "description": "실행할 SQL 쿼리",
        }
    }
    output_type = "string"
    
    def __init__(self, connection_string: str, **kwargs):
        super().__init__(**kwargs)
        self.engine = create_engine(connection_string)
        self._update_description()
    
    def _update_description(self):
        """스키마 정보로 description 업데이트"""
        inspector = inspect(self.engine)
        
        schema_info = "사용 가능한 테이블:\n"
        for table_name in inspector.get_table_names():
            schema_info += f"\n테이블: {table_name}\n"
            columns = inspector.get_columns(table_name)
            for col in columns:
                schema_info += f"  - {col['name']}: {col['type']}\n"
        
        self.description = f"""
SQL 쿼리를 실행하고 결과를 반환합니다.

{schema_info}

Args:
    query: 실행할 SQL 쿼리 (올바른 SQL 문법 필요)
"""
    
    def forward(self, query: str) -> str:
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(query))
                rows = result.fetchall()
                
                if not rows:
                    return "결과 없음"
                
                output = " | ".join(result.keys()) + "\n"
                for row in rows:
                    output += " | ".join(str(v) for v in row) + "\n"
                
                return output
        except Exception as e:
            return f"오류: {e}"


# 사용
sql_tool = SQLTool("sqlite:///my_database.db")
agent = CodeAgent(
    tools=[sql_tool],
    model=InferenceClientModel(),
)
```

---

## 6. 프로덕션 배포 고려사항

### 6.1 보안 샌드박스

```python
import os
from smolagents import CodeAgent, InferenceClientModel

# E2B 샌드박스 사용
os.environ["E2B_API_KEY"] = "your-e2b-api-key"

agent = CodeAgent(
    tools=[],
    model=InferenceClientModel(),
    use_e2b_executor=True,  # E2B 샌드박스 활성화
)

# Docker 샌드박스 사용
from smolagents.sandbox import DockerSandbox

sandbox = DockerSandbox(
    image="python:3.11-slim",
    timeout=30,
)

agent = CodeAgent(
    tools=[],
    model=InferenceClientModel(),
    code_executor=sandbox,
)
```

### 6.2 에러 핸들링

```python
from smolagents import CodeAgent, InferenceClientModel

def safe_agent_run(agent, task: str, max_retries: int = 3):
    """안전한 Agent 실행"""
    for attempt in range(max_retries):
        try:
            result = agent.run(task)
            return {"success": True, "result": result}
        except Exception as e:
            print(f"시도 {attempt + 1} 실패: {e}")
            if attempt == max_retries - 1:
                return {"success": False, "error": str(e)}
    return {"success": False, "error": "Max retries exceeded"}


# 사용
agent = CodeAgent(
    tools=[],
    model=InferenceClientModel(),
    max_steps=10,
)

response = safe_agent_run(agent, "복잡한 계산을 수행해줘")
if response["success"]:
    print(response["result"])
else:
    print(f"실패: {response['error']}")
```

### 6.3 로깅 및 모니터링

```python
import logging
from smolagents import CodeAgent, InferenceClientModel

# 로깅 설정
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler("agent.log"),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("smolagents")

# verbosity 설정
agent = CodeAgent(
    tools=[],
    model=InferenceClientModel(),
    verbosity_level=2,  # 0: 최소, 1: 중간, 2: 상세
)
```

### 6.4 비용 최적화

```python
from smolagents import CodeAgent, InferenceClientModel

# 스텝 제한으로 비용 관리
agent = CodeAgent(
    tools=[],
    model=InferenceClientModel(
        model_id="Qwen/Qwen2.5-72B-Instruct",
    ),
    max_steps=5,           # 최대 스텝 수 제한
    planning_interval=3,   # 계획 수립 간격
)

# Rate Limiting
from smolagents import LiteLLMModel

model = LiteLLMModel(
    model_id="gpt-4o",
    requests_per_minute=10,  # 분당 요청 제한
)
```

### 6.5 캐싱

```python
from functools import lru_cache
from smolagents import Tool


class CachedRetrieverTool(Tool):
    """캐싱이 적용된 검색 도구"""
    
    name = "cached_retriever"
    description = "캐싱된 검색을 수행합니다."
    inputs = {"query": {"type": "string", "description": "검색 쿼리"}}
    output_type = "string"
    
    def __init__(self, retriever, **kwargs):
        super().__init__(**kwargs)
        self.retriever = retriever
    
    @lru_cache(maxsize=100)
    def _cached_search(self, query: str) -> str:
        """검색 결과 캐싱"""
        results = self.retriever.invoke(query)
        return "\n".join([doc.page_content for doc in results])
    
    def forward(self, query: str) -> str:
        return self._cached_search(query)
```

---

## 7. 실습 과제

### 과제 1: 이미지 분석 Agent
1. 이미지 분류 Tool 구현
2. 객체 탐지 Tool 구현
3. Vision Agent로 "이미지 분석 후 설명" 파이프라인 구축

### 과제 2: MCP 기반 데이터 Agent
1. 커스텀 MCP 서버 구현 (날씨, 뉴스 등)
2. smolagents와 연동
3. 여러 MCP 서버 조합 Agent 구축

### 과제 3: Agentic RAG 시스템
1. PDF 문서 로드 및 청킹
2. Vector + BM25 Hybrid Retriever Tool
3. 반복 검색 및 쿼리 개선 Agent 구현

### 과제 4: Text-to-SQL 시스템
1. 실제 데이터베이스 연결
2. 스키마 자동 추출 SQL Tool
3. 자연어 대화형 쿼리 인터페이스

---

## 8. 요약 체크리스트

### Vision & Web Agent
- [ ] VLM 모델로 이미지 입력 처리
- [ ] 스크린샷 콜백 구현
- [ ] Helium으로 브라우저 자동화
- [ ] Web Agent CLI (webagent) 사용

### MCP 통합
- [ ] smolagents MCP 지원 설치
- [ ] ToolCollection.from_mcp() 사용
- [ ] MCPClient로 다중 서버 연결
- [ ] 커스텀 MCP 서버 구현 (FastMCP)

### RAG & SQL
- [ ] RetrieverTool 구현 (BM25, Vector)
- [ ] Agentic RAG 파이프라인 구축
- [ ] SQL Tool 구현 (스키마 자동 추출)
- [ ] Multi-table JOIN 지원

### 프로덕션
- [ ] 보안 샌드박스 (E2B, Docker)
- [ ] 에러 핸들링 및 재시도
- [ ] 로깅 및 모니터링
- [ ] 비용 최적화 (스텝 제한, Rate Limit)

---

## 참고 자료

### 공식 문서
- **Vision Agents**: https://huggingface.co/blog/smolagents-can-see
- **Web Browser Agent**: https://huggingface.co/docs/smolagents/en/examples/web_browser
- **Agentic RAG**: https://huggingface.co/docs/smolagents/en/examples/rag
- **Text-to-SQL**: https://huggingface.co/docs/smolagents/en/examples/text_to_sql

### MCP
- **MCP 공식 사이트**: https://modelcontextprotocol.io
- **MCP 서버 목록**: https://glama.ai/mcp/servers
- **FastMCP**: https://github.com/jlowin/fastmcp

### 추가 리소스
- **HF Agents Course**: https://huggingface.co/learn/agents-course
- **HF Cookbook - Agents**: https://huggingface.co/learn/cookbook/en/agents
- **SmolVLM**: https://huggingface.co/blog/smolvlm

---

## 다음 단계

**Part 5.3: Production Agent Projects**에서 다룰 내용:
- 실전 프로젝트: 리서치 Agent, 코딩 Assistant
- 에러 핸들링 및 폴백 전략
- 성능 최적화 및 벤치마킹
- 배포 및 모니터링 (Gradio, API)